<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>One-Shot Brick Volley</title>
<style>
  :root {
    --bg: #0f1221;
    --panel: #151833;
    --accent: #5dd3ff;
    --good: #77ff77;
    --warn: #ffcc66;
    --bad: #ff6b6b;
    --text: #e7ecf2;
    --muted: #96a1b0;
  }
  html, body {
    margin: 0;
    height: 100%;
    background: radial-gradient(1200px 800px at 30% -10%, #1b2044 0%, var(--bg) 60%);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  .wrap {
    max-width: 720px;
    margin: 0 auto;
    padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom);
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 10px;
    height: 100dvh;
    box-sizing: border-box;
  }
  header, footer {
    display: flex; align-items: center; justify-content: space-between;
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.08));
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    padding: 8px 12px;
    backdrop-filter: blur(6px);
  }
  header .stat {
    display: inline-flex; align-items: center; gap: 8px;
    padding: 6px 10px; border-radius: 8px;
    background: #101433; border: 1px solid rgba(255,255,255,0.08);
    font-weight: 600;
  }
  header .stat .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); }
  header .btns { display: inline-flex; gap: 8px; }
  button {
    appearance: none; border: 1px solid rgba(255,255,255,0.14);
    background: #111534; color: var(--text);
    padding: 8px 12px; border-radius: 10px; font-weight: 600; cursor: pointer;
  }
  button:hover { filter: brightness(1.06); }
  button:active { transform: translateY(0.5px); }
  #gameCanvas {
    width: 100%; height: auto; display: block;
    background:
      linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12)),
      radial-gradient(900px 600px at 70% 10%, rgba(93,211,255,0.08), rgba(0,0,0,0) 60%);
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 40px rgba(0,0,0,0.35), inset 0 0 40px rgba(93,211,255,0.08);
    touch-action: none;
  }
  .overlay {
    position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;
  }
  .card {
    pointer-events: auto;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 14px; padding: 18px; max-width: 520px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    text-align: center;
  }
  .title {
    font-weight: 800; font-size: 24px; letter-spacing: 0.2px; margin: 4px 0 2px;
  }
  .subtitle { color: var(--muted); margin-bottom: 14px; }
  .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #0e1230; border: 1px solid rgba(255,255,255,0.12); padding: 2px 6px; border-radius: 6px; }
  footer { justify-content: center; gap: 16px; color: var(--muted); font-size: 14px; }
  .link { color: var(--accent); text-decoration: none; font-weight: 600; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="stat"><span class="dot"></span> Level <span id="levelVal">1</span></div>
      <div class="stat"><span class="dot" style="background:var(--good)"></span> Balls <span id="ballsVal">1</span></div>
      <div class="stat"><span class="dot" style="background:var(--warn)"></span> Score <span id="scoreVal">0</span></div>
      <div class="btns">
        <button id="pauseBtn" aria-label="Pause">Pause</button>
        <button id="restartBtn" aria-label="Restart">Restart</button>
        <button id="muteBtn" aria-label="Mute">Mute</button>
      </div>
    </header>

    <div style="position:relative;">
      <canvas id="gameCanvas" width="600" height="960" aria-label="Brick volley game area"></canvas>

      <!-- Start / Pause / Game Over overlays -->
      <div id="startOverlay" class="overlay">
        <div class="card">
          <div class="title">One-Shot Brick Volley</div>
          <div class="subtitle">Drag to aim. Release to shoot. Pick up <strong>+1</strong> balls. Keep blocks off the bottom.</div>
          <p style="margin:10px 0 14px;">
            Desktop: click and drag. Mobile: touch and drag.  
            Press <span class="kbd">R</span> to restart, <span class="kbd">P</span> to pause.
          </p>
          <button id="startBtn">Play</button>
        </div>
      </div>

      <div id="pauseOverlay" class="overlay" style="display:none;">
        <div class="card">
          <div class="title">Paused</div>
          <div class="subtitle">Take a breather.</div>
          <button id="resumeBtn">Resume</button>
        </div>
      </div>

      <div id="gameOverOverlay" class="overlay" style="display:none;">
        <div class="card">
          <div class="title">Game Over</div>
          <div class="subtitle">A block reached the bottom row.</div>
          <p style="margin: 6px 0 14px;">
            Score: <strong id="finalScore">0</strong> Â· Best: <strong id="bestScore">0</strong>
          </p>
          <button id="againBtn">Play Again</button>
        </div>
      </div>
    </div>

    <footer>
      <div>Tip: your next shot starts where the first returning ball lands.</div>
    </footer>
  </div>

<script>
(() => {
  // ---------- Canvas + DPI ----------
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function fitCanvas() {
    // Keep a tall portrait aspect; clamp for phones/tablets.
    const cssW = Math.min(window.innerWidth - 24, 720);
    const cssH = Math.min(window.innerHeight - 160, 1200);
    const aspect = 600 / 960;  // base aspect
    let w = cssW, h = Math.floor(cssW / aspect);
    if (h > cssH) { h = cssH; w = Math.floor(cssH * aspect); }
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  // ---------- Game constants ----------
  const COLS = 8;
  const PAD = 14;
  const TOP_PAD = 70;
  const BOTTOM_PAD = 84;
  const BALL_R = 6;
  const BASE_SPEED = 420; // px/s
  const FIRE_INTERVAL = 55; // ms between balls in a volley
  const ROW_DROP_MS = 180; // soft animation duration when rows drop
  const MAX_ROWS = 13; // visible grid rows
  const PICKUP_RATE = 0.22; // chance to spawn +1 in a column
  const BLOCK_RATE_BASE = 0.55; // baseline chance a column spawns a block
  const MAX_AIM_ANGLE = Math.PI * 0.47; // limit shallow shots along bottom

  let state = 'READY'; // READY, AIM, FIRING, BETWEEN, PAUSED, OVER
  let level = 1;
  let score = 0;
  let best = Number(localStorage.getItem('oneShotBest') || 0);

  // Grid metrics
  function cellSize() { return (canvas.width/ (window.devicePixelRatio||1) - PAD*2) / COLS; }
  function gridLeft() { return PAD; }
  function gridTop() { return TOP_PAD; }
  function gridBottomY() { return gridTop() + MAX_ROWS * cellSize(); }

  // UI elements
  const levelEl = document.getElementById('levelVal');
  const ballsEl = document.getElementById('ballsVal');
  const scoreEl = document.getElementById('scoreVal');
  const startOverlay = document.getElementById('startOverlay');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreEl = document.getElementById('finalScore');
  const bestScoreEl = document.getElementById('bestScore');

  // Controls
  document.getElementById('startBtn').onclick = startGame;
  document.getElementById('againBtn').onclick = restart;
  document.getElementById('pauseBtn').onclick = togglePause;
  document.getElementById('resumeBtn').onclick = togglePause;
  document.getElementById('restartBtn').onclick = restart;
  const muteBtn = document.getElementById('muteBtn');
  muteBtn.onclick = () => { muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Mute'; };

  // Keyboard
  window.addEventListener('keydown', e => {
    if (e.key === 'p' || e.key === 'P') togglePause();
    if (e.key === 'r' || e.key === 'R') restart();
  });

  // ---------- Entities ----------
  /** Blocks live in grid coords (c,r) with hp */
  const blocks = [];
  /** Pickups live in grid coords with type 'ball' (+1) */
  const pickups = [];
  /** Active volley balls */
  let balls = [];
  /** Number of balls per volley */
  let ballCount = 1;
  /** Where the next shot originates */
  let origin = { x: canvas.width/(window.devicePixelRatio||1) / 2, y: gridBottomY() - 12 };
  let pendingFireDir = null;
  let fireTimer = 0;
  let firedThisVolley = 0;
  let returnedThisVolley = 0;
  let firstReturnX = null;
  let rowDropAnim = 0; // 0..1 during row drop animation
  let paused = false;
  let muted = false;

  // ---------- Simple SFX (beeps via WebAudio) ----------
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function beep(freq=600, time=0.05, gain=0.03) {
    if (muted) return;
    if (!audioCtx) {
      try { audioCtx = new AudioContext(); } catch {}
    }
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square'; o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + time);
  }

  // ---------- Utility ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  function worldFromEvent(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.touches ? ev.touches[0].clientX : ev.clientX) - rect.left;
    const y = (ev.touches ? ev.touches[0].clientY : ev.clientY) - rect.top;
    return { x, y };
  }
  function colX(c) { return gridLeft() + c * cellSize(); }
  function rowY(r) { return gridTop() + r * cellSize(); }

  // ---------- Row spawning ----------
  function spawnRow() {
    // Move everything down by one row
    for (const b of blocks) b.r += 1;
    for (const p of pickups) p.r += 1;

    // Check loss
    for (const b of blocks) {
      if (b.r >= MAX_ROWS) {
        gameOver();
        return;
      }
    }

    // Top row spawns
    const r = 0;
    const spawnChance = clamp(BLOCK_RATE_BASE + level * 0.01, 0.55, 0.9);
    const cols = [...Array(COLS).keys()];
    let spawned = 0;
    for (const c of cols) {
      if (Math.random() < spawnChance) {
        const hp = Math.max(1, Math.floor(level + (Math.random() * (2 + level * 0.2))));
        blocks.push({ c, r, hp, hitCooldown: 0 });
        spawned++;
      } else if (Math.random() < PICKUP_RATE) {
        pickups.push({ c, r, type: 'ball', pulse: Math.random()*Math.PI*2 });
      }
    }
    // Ensure at least one thing appears
    if (spawned === 0) {
      const c = Math.floor(Math.random() * COLS);
      blocks.push({ c, r, hp: level, hitCooldown: 0 });
    }
    rowDropAnim = 1; // trigger drop animation
  }

  // ---------- Game lifecycle ----------
  function startGame() {
    startOverlay.style.display = 'none';
    state = 'AIM';
    beep(440, 0.06, 0.02);
    level = 1; score = 0;
    blocks.length = 0; pickups.length = 0; balls = [];
    ballCount = 1; firedThisVolley = 0; returnedThisVolley = 0; firstReturnX = null;
    levelEl.textContent = level; ballsEl.textContent = ballCount; scoreEl.textContent = score;
    origin.x = canvas.width/(window.devicePixelRatio||1) / 2;
    origin.y = gridBottomY() - 12;
    spawnRow(); // start with an initial row
  }

  function restart() {
    if (state === 'READY') { startOverlay.style.display = ''; return; }
    gameOverOverlay.style.display = 'none';
    startGame();
  }

  function togglePause() {
    if (state === 'OVER' || state === 'READY') return;
    paused = !paused;
    pauseOverlay.style.display = paused ? '' : 'none';
  }

  function gameOver() {
    state = 'OVER';
    best = Math.max(best, score);
    localStorage.setItem('oneShotBest', String(best));
    finalScoreEl.textContent = String(score);
    bestScoreEl.textContent = String(best);
    gameOverOverlay.style.display = '';
    beep(160, 0.2, 0.04);
  }

  // ---------- Input: aim + fire ----------
  let aiming = false;
  let aimPoint = null;

  const startAim = (e) => {
    if (state !== 'AIM') return;
    e.preventDefault();
    aiming = true;
    aimPoint = worldFromEvent(e);
  };
  const moveAim = (e) => {
    if (!aiming) return;
    aimPoint = worldFromEvent(e);
  };
  const endAim = (e) => {
    if (!aiming) return;
    aiming = false;
    if (!aimPoint) return;
    const dx = aimPoint.x - origin.x;
    const dy = aimPoint.y - origin.y;
    let angle = Math.atan2(dy, dx);
    // Only allow shots upwards, clamp shallow angle
    if (angle > -0.05) angle = -0.05;
    const centerAngle = -Math.PI/2;
    angle = clamp(angle, centerAngle - MAX_AIM_ANGLE, centerAngle + MAX_AIM_ANGLE);
    pendingFireDir = { x: Math.cos(angle), y: Math.sin(angle) };
    startVolley();
  };

  canvas.addEventListener('pointerdown', startAim);
  canvas.addEventListener('pointermove', moveAim);
  window.addEventListener('pointerup', endAim);
  // Touch fallback
  canvas.addEventListener('touchstart', startAim, { passive: false });
  canvas.addEventListener('touchmove', moveAim, { passive: false });
  canvas.addEventListener('touchend', endAim);

  function startVolley() {
    if (!pendingFireDir) return;
    if (state !== 'AIM') return;
    state = 'FIRING';
    firedThisVolley = 0;
    returnedThisVolley = 0;
    firstReturnX = null;
    fireTimer = 0;
    beep(520, 0.05, 0.03);
  }

  // ---------- Physics update ----------
  function addBall() {
    const dir = pendingFireDir;
    balls.push({
      x: origin.x, y: origin.y,
      vx: dir.x * BASE_SPEED, vy: dir.y * BASE_SPEED,
      r: BALL_R
    });
    firedThisVolley++;
    if (firedThisVolley >= ballCount) {
      // all created
      pendingFireDir = null;
    }
  }

  function update(dt) {
    // Row drop animation decay
    if (rowDropAnim > 0) {
      rowDropAnim -= dt / (ROW_DROP_MS/1000);
      if (rowDropAnim < 0) rowDropAnim = 0;
    }

    // Cooldowns
    for (const b of blocks) if (b.hitCooldown > 0) b.hitCooldown -= dt;

    if (state === 'FIRING') {
      fireTimer += dt * 1000;
      while (fireTimer >= FIRE_INTERVAL && firedThisVolley < ballCount) {
        fireTimer -= FIRE_INTERVAL;
        addBall();
      }
      if (firedThisVolley >= ballCount && balls.length === 0) {
        // edge: if volley finished instantly (unlikely), advance
        finishVolley();
      }
    }

    // Ball movement
    if (state === 'FIRING' || state === 'BETWEEN') {
      // Use substeps for stability
      const steps = 2;
      const stepDT = dt / steps;
      for (let s = 0; s < steps; s++) {
        for (let i = balls.length - 1; i >= 0; i--) {
          const b = balls[i];
          b.x += b.vx * stepDT;
          b.y += b.vy * stepDT;

          // Walls
          const left = PAD + BALL_R;
          const right = (canvas.width/(window.devicePixelRatio||1)) - PAD - BALL_R;
          if (b.x <= left) { b.x = left; b.vx = Math.abs(b.vx); beep(900,0.02,0.01); }
          if (b.x >= right) { b.x = right; b.vx = -Math.abs(b.vx); beep(900,0.02,0.01); }
          // Ceiling
          const ceil = gridTop() + BALL_R;
          if (b.y <= ceil) { b.y = ceil; b.vy = Math.abs(b.vy); beep(900,0.02,0.01); }
          // Floor return
          const floor = gridBottomY() - BALL_R;
          if (b.y >= floor) {
            // First return anchors next origin
            if (firstReturnX === null) firstReturnX = b.x;
            returnedThisVolley++;
            balls.splice(i,1);
            if (returnedThisVolley >= ballCount && state !== 'BETWEEN') {
              finishVolley();
            }
            continue;
          }

          // Block collisions
          for (let j = blocks.length - 1; j >= 0; j--) {
            const blk = blocks[j];
            if (blk.hitCooldown > 0) continue;
            const rx = colX(blk.c), ry = rowY(blk.r);
            const w = cellSize(), h = cellSize();
            const nx = clamp(b.x, rx, rx + w);
            const ny = clamp(b.y, ry + dropOffset(), ry + h + dropOffset());
            const dx = b.x - nx, dy = b.y - ny;
            const d2 = dx*dx + dy*dy;
            if (d2 < b.r * b.r) {
              // Determine primary axis
              if (Math.abs(dx) > Math.abs(dy)) {
                b.vx = (dx > 0) ? Math.abs(b.vx) : -Math.abs(b.vx);
              } else {
                b.vy = (dy > 0) ? Math.abs(b.vy) : -Math.abs(b.vy);
              }
              // Nudge out
              const d = Math.sqrt(Math.max(0.0001, d2));
              const nxv = (d ? dx/d : 0), nyv = (d ? dy/d : -1);
              b.x = nx + nxv * (b.r + 0.1);
              b.y = ny + nyv * (b.r + 0.1);

              // Damage
              blk.hp -= 1;
              blk.hitCooldown = 0.015;
              score += 1;
              scoreEl.textContent = score;
              beep(680 + Math.random()*60, 0.02, 0.02);
              if (blk.hp <= 0) {
                blocks.splice(j,1);
                beep(520, 0.06, 0.03);
              }
              break; // a ball hits max one block per substep
            }
          }

          // Pickup collisions (simple AABB)
          for (let j = pickups.length - 1; j >= 0; j--) {
            const p = pickups[j];
            const rx = colX(p.c), ry = rowY(p.r) + dropOffset();
            const w = cellSize(), h = cellSize();
            if (b.x > rx && b.x < rx+w && b.y > ry && b.y < ry+h) {
              if (p.type === 'ball') {
                ballCount += 1;
                ballsEl.textContent = ballCount;
                pickups.splice(j,1);
                beep(880, 0.06, 0.03);
              }
            }
          }
        }
      }
    }
  }

  function dropOffset() {
    // Smooth visual drop for the last spawn
    return rowDropAnim > 0 ? (1 - rowDropAnim) * cellSize() : 0;
  }

  function finishVolley() {
    // Re-anchor origin at first returning ball
    if (firstReturnX !== null) {
      const left = PAD + BALL_R;
      const right = (canvas.width/(window.devicePixelRatio||1)) - PAD - BALL_R;
      origin.x = clamp(firstReturnX, left, right);
    }
    state = 'BETWEEN';
    // Advance level, spawn new row, then allow aim
    level += 1;
    levelEl.textContent = level;
    spawnRow();
    // After the short drop animation, return to AIM
    setTimeout(() => {
      if (state !== 'OVER') state = 'AIM';
    }, ROW_DROP_MS + 10);
  }

  // ---------- Rendering ----------
  function draw() {
    const W = canvas.width/(window.devicePixelRatio||1);
    const H = canvas.height/(window.devicePixelRatio||1);
    // Clear
    ctx.clearRect(0,0,W,H);

    // Board frame
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(PAD-1, gridTop()-1, W - (PAD*2) + 2, gridBottomY() - gridTop() + 2);
    ctx.restore();

    // Grid lines (light)
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    for (let c=1; c<COLS; c++){
      const x = colX(c);
      ctx.beginPath(); ctx.moveTo(x, gridTop()); ctx.lineTo(x, gridBottomY()); ctx.stroke();
    }
    for (let r=1; r<MAX_ROWS; r++){
      const y = rowY(r) + dropOffset();
      ctx.beginPath(); ctx.moveTo(PAD, y); ctx.lineTo(W-PAD, y); ctx.stroke();
    }
    ctx.restore();

    // Blocks
    for (const b of blocks) {
      const x = colX(b.c), y = rowY(b.r) + dropOffset(), s = cellSize();
      const pct = clamp(b.hp / (level + 6), 0, 1);
      const col = hpColor(pct);
      roundRect(ctx, x+4, y+4, s-8, s-8, 10);
      ctx.fillStyle = col.fill; ctx.fill();
      ctx.strokeStyle = col.stroke; ctx.lineWidth = 2; ctx.stroke();
      // HP text
      ctx.fillStyle = '#eaf2ff';
      ctx.font = `${Math.floor(s*0.36)}px ui-sans-serif, system-ui`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(String(b.hp), x + s/2, y + s/2 + 1);
    }

    // Pickups
    for (const p of pickups) {
      const x = colX(p.c), y = rowY(p.r) + dropOffset(), s = cellSize();
      const cx = x + s/2, cy = y + s/2;
      const t = (performance.now()/1000) + p.pulse;
      const r = Math.max(8, s*0.18) + Math.sin(t*2)*1.3;
      // glow
      ctx.beginPath(); ctx.arc(cx, cy, r+6, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(119,255,119,0.12)'; ctx.fill();
      // coin
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fillStyle = '#35d66b'; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = '#0c9a3f'; ctx.stroke();
      // + symbol
      ctx.strokeStyle = '#0a3';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(cx - r*0.45, cy); ctx.lineTo(cx + r*0.45, cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx, cy - r*0.45); ctx.lineTo(cx, cy + r*0.45); ctx.stroke();
    }

    // Aim guide
    if (state === 'AIM' && (aiming || aimPoint)) {
      const a = aimPoint || {x: origin.x, y: origin.y - 80};
      const dx = a.x - origin.x, dy = a.y - origin.y;
      let ang = Math.atan2(dy, dx);
      if (ang > -0.05) ang = -0.05;
      const center = -Math.PI/2;
      ang = clamp(ang, center - MAX_AIM_ANGLE, center + MAX_AIM_ANGLE);
      const dir = { x: Math.cos(ang), y: Math.sin(ang) };
      const len = 140;
      ctx.strokeStyle = 'rgba(93,211,255,0.85)';
      ctx.lineWidth = 3;
      ctx.setLineDash([8,8]);
      ctx.beginPath();
      ctx.moveTo(origin.x, origin.y);
      ctx.lineTo(origin.x + dir.x * len, origin.y + dir.y * len);
      ctx.stroke();
      ctx.setLineDash([]);
      // little arrow head
      ctx.beginPath();
      ctx.arc(origin.x + dir.x * len, origin.y + dir.y * len, 4, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(93,211,255,0.9)'; ctx.fill();
    }

    // Balls + origin
    // Origin indicator
    ctx.beginPath();
    ctx.arc(origin.x, origin.y, BALL_R+2, 0, Math.PI*2);
    ctx.fillStyle = '#d0f1ff'; ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = '#5dd3ff'; ctx.stroke();

    // Active balls
    for (const b of balls) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = '#e8fbff'; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(93,211,255,0.6)'; ctx.stroke();
    }
  }

  function hpColor(p) {
    // p in [0..1], map to color bands
    // greener for low hp, warmer for high hp
    const lerp = (a,b,t)=>a+(b-a)*t;
    const toHex = v => ('0'+Math.round(clamp(v,0,255)).toString(16)).slice(-2);
    const g = {r: 80, g: 220, b: 140};
    const y = {r: 255, g: 210, b: 90};
    const r = {r: 255, g: 100, b: 100};
    let c1, c2, t;
    if (p < 0.5) { c1 = g; c2 = y; t = p/0.5; } else { c1 = y; c2 = r; t = (p-0.5)/0.5; }
    const rr = lerp(c1.r, c2.r, t), gg = lerp(c1.g, c2.g, t), bb = lerp(c1.b, c2.b, t);
    const fill = `#${toHex(rr)}${toHex(gg)}${toHex(bb)}`;
    const stroke = `rgba(0,0,0,0.35)`;
    return { fill, stroke };
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
  }

  // ---------- Main loop ----------
  let last = performance.now();
  function loop(now) {
    requestAnimationFrame(loop);
    if (paused || state === 'OVER' || state === 'READY') { draw(); return; }
    const dt = clamp((now - last)/1000, 0, 0.033);
    last = now;
    update(dt);
    draw();
  }
  requestAnimationFrame(loop);

  // Initial overlay remains until Start
  function showStart() {
    state = 'READY';
    startOverlay.style.display = '';
    levelEl.textContent = 1; ballsEl.textContent = 1; scoreEl.textContent = 0;
  }
  showStart();

  // Start button for overlay
  // handled in startGame()

})();
</script>
</body>
</html>
