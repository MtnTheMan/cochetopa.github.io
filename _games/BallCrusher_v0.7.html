---
title: "BallCrusher v0.7"
---

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>One-Shot Brick Volley — v7 (mobile-scaled)</title>
<style>
  :root {
    --bg:#0f1221; --panel:#151833; --accent:#5dd3ff;
    --good:#77ff77; --warn:#ffcc66; --bad:#ff6b6b;
    --text:#e7ecf2; --muted:#96a1b0;
  }
  html,body{margin:0;height:100%;background:radial-gradient(1200px 800px at 30% -10%, #1b2044 0%, var(--bg) 60%);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
  body{overscroll-behavior:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;}
  .wrap{
    /* let it grow on mobile; capped on desktop via media query */
    max-width:100%;
    margin:0 auto;
    padding:env(safe-area-inset-top) 12px env(safe-area-inset-bottom);
    display:grid;grid-template-rows:auto 1fr auto;gap:10px;
    height:100svh;
  }
  @media (min-width:880px){
    .wrap{max-width:960px;height:100dvh;}
  }
  header,footer{
    display:flex;align-items:center;justify-content:space-between;
    background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(0,0,0,0.08));
    border:1px solid rgba(255,255,255,0.08);
    border-radius:12px;padding:8px 12px;backdrop-filter:blur(6px);
  }
  header .stat{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:8px;background:#101433;border:1px solid rgba(255,255,255,0.08);font-weight:600;}
  header .stat .dot{width:8px;height:8px;border-radius:50%;background:var(--accent);}
  header .btns{display:inline-flex;gap:8px;}
  button{appearance:none;border:1px solid rgba(255,255,255,0.14);background:#111534;color:var(--text);padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer;}
  button:hover{filter:brightness(1.06)} button:active{transform:translateY(0.5px)}
  .board{position:relative}
  #gameCanvas{
    width:100%;height:auto;display:block;
    background:
      linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.12)),
      radial-gradient(900px 600px at 70% 10%,rgba(93,211,255,0.08),rgba(0,0,0,0) 60%);
    border-radius:14px;border:1px solid rgba(255,255,255,0.08);
    box-shadow:0 10px 40px rgba(0,0,0,0.35),inset 0 0 40px rgba(93,211,255,0.08);
    touch-action:none;-webkit-tap-highlight-color:transparent;
  }
  .overlay{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
  .card{pointer-events:auto;background:var(--panel);border:1px solid rgba(255,255,255,0.12);border-radius:14px;padding:18px;max-width:520px;box-shadow:0 10px 40px rgba(0,0,0,0.5);text-align:center}
  .title{font-weight:800;font-size:24px;letter-spacing:.2px;margin:4px 0 2px}
  .subtitle{color:var(--muted);margin-bottom:14px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0e1230;border:1px solid rgba(255,255,255,0.12);padding:2px 6px;border-radius:6px}
  footer{justify-content:center;gap:16px;color:var(--muted);font-size:14px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="stat"><span class="dot"></span> Level <span id="levelVal">1</span></div>
      <div class="stat"><span class="dot" style="background:var(--good)"></span> Balls <span id="ballsVal">1</span></div>
      <div class="stat"><span class="dot" style="background:var(--warn)"></span> Score <span id="scoreVal">0</span></div>
      <div class="btns">
        <button id="pauseBtn" aria-label="Pause">Pause</button>
        <button id="restartBtn" aria-label="Restart">Restart</button>
        <button id="muteBtn" aria-label="Mute">Mute</button>
      </div>
    </header>

    <div class="board">
      <canvas id="gameCanvas" width="600" height="960" aria-label="Brick volley game area"></canvas>

      <div id="startOverlay" class="overlay">
        <div class="card">
          <div class="title">One-Shot Brick Volley</div>
          <div class="subtitle">Drag to aim. Release to shoot. Pick up <strong>+1</strong> balls. Keep blocks off the bottom.</div>
          <p style="margin:10px 0 14px;">
            Desktop: click and drag. Mobile: touch and drag.
            Press <span class="kbd">R</span> to restart, <span class="kbd">P</span> to pause.
          </p>
          <button id="startBtn">Play</button>
        </div>
      </div>

      <div id="pauseOverlay" class="overlay" style="display:none;">
        <div class="card">
          <div class="title">Paused</div>
          <div class="subtitle">Take a breather.</div>
          <button id="resumeBtn">Resume</button>
        </div>
      </div>

      <div id="gameOverOverlay" class="overlay" style="display:none;">
        <div class="card">
          <div class="title">Game Over</div>
          <div class="subtitle">A block reached the bottom row.</div>
          <p style="margin: 6px 0 14px;">
            Score: <strong id="finalScore">0</strong> · Best: <strong id="bestScore">0</strong>
          </p>
          <button id="againBtn">Play Again</button>
        </div>
      </div>
    </div>

    <footer><div>Tip: corner clips can “stick” a ball; long volleys get faster.</div></footer>
  </div>

<script>
(() => {
  // ---------- Canvas + DPI + Mobile viewport ----------
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  const header = document.querySelector('header');
  const footer = document.querySelector('footer');

  // Board geometry (portrait 600x960 base aspect)
  const BASE_ASPECT = 600 / 960; // width / height = 0.625

  function vvHeight(){ return (window.visualViewport && window.visualViewport.height) || window.innerHeight; }

  function fitCanvas() {
    // Available rectangle between header and footer
    const chromeH = header.offsetHeight + footer.offsetHeight + 20; // padding + spacing
    const maxH = Math.max(420, vvHeight() - chromeH);
    const maxW = Math.max(320, document.documentElement.clientWidth - 24);

    // Fit the 0.625 aspect rectangle into available space
    let cssW = maxW;
    let cssH = Math.floor(cssW / BASE_ASPECT);
    if (cssH > maxH) { cssH = Math.floor(maxH); cssW = Math.floor(cssH * BASE_ASPECT); }

    // Scale up to device pixels (crisp on retina)
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 3)); // allow 3x on newer phones
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);

    // Reset transforms & configure paint quality
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.lineJoin = 'round';      // prevents “spiky” corners
    ctx.miterLimit = 2;          // clamps miters if any appear
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas, { passive:true });
  if (window.visualViewport) window.visualViewport.addEventListener('resize', fitCanvas, { passive:true });

  // ---------- Game constants (unchanged core, mobile-tuned padding) ----------
  const COLS = 12;
  const PAD = 12;             // slightly tighter to win a bit more canvas on phones
  const TOP_PAD_DESKTOP = 70;
  const TOP_PAD_MOBILE  = 54; // smaller top pad on phones for larger grid
  const MAX_ROWS = 13;
  const BALL_R = 6;

  const BASE_SPEED = 420, FIRE_INTERVAL = 55, ROW_DROP_MS = 180;
  const PICKUP_RATE = 0.22, BLOCK_RATE_BASE = 0.55;

  // nearly horizontal aiming, forbid downward
  const MAX_AIM_ANGLE = Math.PI * 0.499;
  const UPWARD_LIMIT  = -0.001;

  // speed boosts
  const SPEED1_AFTER_MS = 10000, SPEED1_MULT = 1.75;
  const SPEED2_AFTER_MS = 30000, SPEED2_MULT = 2.5;
  const SPEED3_AFTER_MS = 120000, SPEED3_MULT = 4.5; // 2 minutes, absurdly fast

  // ---------- State ----------
  let state = 'READY';
  let level = 1, score = 0;
  let best = Number(localStorage.getItem('oneShotBest') || 0);

  // Grid metrics (recomputed from CSS size to keep math in CSS pixels)
  const pxW = () => canvas.width / (window.devicePixelRatio || 1);
  const pxH = () => canvas.height / (window.devicePixelRatio || 1);
  function topPad() { return (document.documentElement.clientWidth < 520 ? TOP_PAD_MOBILE : TOP_PAD_DESKTOP); }
  function cellSize() { return (pxW() - PAD*2) / COLS; }
  function gridLeft() { return PAD; }
  function gridTop()  { return topPad(); }
  function gridBottomY() { return gridTop() + MAX_ROWS * cellSize(); }

  // UI
  const levelEl = document.getElementById('levelVal');
  const ballsEl = document.getElementById('ballsVal');
  const scoreEl = document.getElementById('scoreVal');
  const startOverlay = document.getElementById('startOverlay');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreEl = document.getElementById('finalScore');
  const bestScoreEl = document.getElementById('bestScore');

  document.getElementById('startBtn').onclick = startGame;
  document.getElementById('againBtn').onclick = restart;
  document.getElementById('pauseBtn').onclick = togglePause;
  document.getElementById('resumeBtn').onclick = togglePause;
  document.getElementById('restartBtn').onclick = restart;
  const muteBtn = document.getElementById('muteBtn'); let muted = false;
  muteBtn.onclick = () => { muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Mute'; };

  window.addEventListener('keydown', e => {
    if (e.key === 'p' || e.key === 'P') togglePause();
    if (e.key === 'r' || e.key === 'R') restart();
  });

  // ---------- Entities ----------
  const blocks = [];
  const pickups = [];
  let balls = [];

  let ballCount = 1, volleyTarget = 1;
  let origin = { x: pxW()/2, y: gridBottomY() - 22 };

  let pendingFireDir = null, fireTimer = 0, firedThisVolley = 0, returnedThisVolley = 0, firstReturnX = null;
  let rowDropAnim = 0, paused = false;

  // Speed state
  let volleyStartMs = 0, speedMultiplier = 1, lastAppliedMultiplier = 1;

  // ---------- SFX ----------
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function beep(freq=600, time=0.05, gain=0.03) {
    if (muted) return;
    if (!audioCtx) { try { audioCtx = new AudioContext(); } catch {} }
    if (!audioCtx) return;
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type='square'; o.frequency.value=freq; g.gain.value=gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + time);
  }

  // ---------- Utility ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  function worldFromEvent(ev){ const r=canvas.getBoundingClientRect(); const x=(ev.touches?ev.touches[0].clientX:ev.clientX)-r.left; const y=(ev.touches?ev.touches[0].clientY:ev.clientY)-r.top; return {x,y}; }
  const colX = c => gridLeft() + c * cellSize();
  const rowY = r => gridTop()  + r * cellSize();

  function isBlockLive(blk){ return !!(blk && blk.hp>0 && blocks.indexOf(blk)!==-1); }
  function anyBrickNear(x,y,tol = BALL_R + 2){
    for (const blk of blocks){
      const rx = colX(blk.c), ry = rowY(blk.r) + dropOffset(), w = cellSize(), h = cellSize();
      if (x >= rx - tol && x <= rx + w + tol && y >= ry - tol && y <= ry + h + tol) return true;
    }
    return false;
  }
  function releaseStuckBall(b){
    const scale = speedMultiplier / (b.stuckMultAtStart || 1);
    b.vx = (b.resumeVX || ((Math.random()<0.5?-1:1)*BASE_SPEED*0.6)) * scale;
    b.vy = (b.resumeVY || -BASE_SPEED*0.6) * scale;
    b.x = b.stuckX + (b.vx>0?0.6:-0.6);
    b.y = b.stuckY + (b.vy>0?0.6:-0.6);
    b.stuck=false; b.stuckTo=null;
  }

  // ---------- Row spawning ----------
  function spawnRow(){
    for (const b of blocks) b.r += 1;
    for (const p of pickups) p.r += 1;

    for (const b of blocks) if (b.r >= MAX_ROWS) { gameOver(); return; }

    const r=0, spawnChance = clamp(BLOCK_RATE_BASE + level*0.01, 0.55, 0.9);
    let spawned = 0;
    for (let c=0;c<COLS;c++){
      if (Math.random() < spawnChance){
        const hp = Math.max(1, Math.floor(level + (Math.random() * (2 + level * 0.2))));
        blocks.push({ c, r, hp, hitCooldown: 0 }); spawned++;
      } else if (Math.random() < PICKUP_RATE){
        pickups.push({ c, r, type:'ball', pulse: Math.random()*Math.PI*2 });
      }
    }
    if (spawned===0){ const c=Math.floor(Math.random()*COLS); blocks.push({c,r,hp:level,hitCooldown:0}); }
    rowDropAnim = 1;
  }

  // ---------- Lifecycle ----------
  function startGame(){
    startOverlay.style.display='none'; state='AIM'; beep(440,0.06,0.02);
    level=1; score=0; blocks.length=0; pickups.length=0; balls=[];
    ballCount=1; volleyTarget=1; firedThisVolley=0; returnedThisVolley=0; firstReturnX=null;
    speedMultiplier=1; lastAppliedMultiplier=1;
    levelEl.textContent=level; ballsEl.textContent=ballCount; scoreEl.textContent=score;
    origin.x = pxW()/2; origin.y = gridBottomY() - 22;
    spawnRow();
  }
  function restart(){ if (state==='READY'){ startOverlay.style.display=''; return; } gameOverOverlay.style.display='none'; startGame(); }
  function togglePause(){ if (state==='OVER' || state==='READY') return; paused=!paused; pauseOverlay.style.display = paused ? '' : 'none'; }
  function gameOver(){
    state='OVER'; best=Math.max(best,score); localStorage.setItem('oneShotBest', String(best));
    finalScoreEl.textContent=String(score); bestScoreEl.textContent=String(best);
    gameOverOverlay.style.display=''; beep(160,0.2,0.04);
  }

  // ---------- Input / Firing ----------
  let aiming=false, aimPoint=null;
  const startAim = e => { if (state!=='AIM') return; e.preventDefault(); aiming=true; aimPoint=worldFromEvent(e); };
  const moveAim  = e => { if (!aiming) return; aimPoint=worldFromEvent(e); };
  const endAim   = e => {
    if (!aiming) return; aiming=false; if (!aimPoint) return;
    const dx=aimPoint.x-origin.x, dy=aimPoint.y-origin.y;
    let a=Math.atan2(dy,dx); if (a > UPWARD_LIMIT) a = UPWARD_LIMIT;
    const center=-Math.PI/2; a = clamp(a, center - MAX_AIM_ANGLE, center + MAX_AIM_ANGLE);
    pendingFireDir = { x: Math.cos(a), y: Math.sin(a) };
    startVolley();
  };
  canvas.addEventListener('pointerdown', startAim);
  canvas.addEventListener('pointermove',  moveAim);
  window.addEventListener('pointerup',    endAim);
  canvas.addEventListener('touchstart', startAim, { passive:false });
  canvas.addEventListener('touchmove',  moveAim,  { passive:false });
  canvas.addEventListener('touchend',   endAim);

  function startVolley(){
    if (!pendingFireDir || state!=='AIM') return;
    state='FIRING';
    volleyTarget = ballCount;
    firedThisVolley=0; returnedThisVolley=0; firstReturnX=null; fireTimer=0;
    volleyStartMs=performance.now(); speedMultiplier=1; lastAppliedMultiplier=1;
    beep(520,0.05,0.03);
  }

  // ---------- Speed boosts ----------
  function maybeBoostSpeed(nowMs) {
    if (state !== 'FIRING') return;

    const elapsed = nowMs - volleyStartMs;
    let targetMult = 1;

    if (elapsed >= SPEED3_AFTER_MS)      targetMult = SPEED3_MULT;
    else if (elapsed >= SPEED2_AFTER_MS) targetMult = SPEED2_MULT;
    else if (elapsed >= SPEED1_AFTER_MS) targetMult = SPEED1_MULT;

    if (targetMult > lastAppliedMultiplier) {
      const scale = targetMult / lastAppliedMultiplier;
      speedMultiplier = targetMult;

      // Scale velocities of currently-flying balls (stuck balls re-scale on release)
      for (const b of balls) { if (!b.stuck) { b.vx *= scale; b.vy *= scale; } }

      lastAppliedMultiplier = targetMult;

      // Higher tone per tier: 1→980Hz, 2→1180Hz, 3→1450Hz
      const tone = (targetMult >= SPEED3_MULT) ? 1450 : (targetMult >= SPEED2_MULT ? 1180 : 980);
      beep(tone, 0.08, 0.03);
    }
  }

  // ---------- Physics ----------
  function addBall(){
    const dir = pendingFireDir, spd = BASE_SPEED * speedMultiplier;
    balls.push({
      x: origin.x, y: origin.y, vx: dir.x * spd, vy: dir.y * spd, r: BALL_R,
      stuck:false, stuckTo:null, stuckX:0, stuckY:0, resumeVX:0, resumeVY:0, stuckTick:0, stuckMultAtStart:1
    });
    firedThisVolley++; if (firedThisVolley >= volleyTarget) pendingFireDir = null;
  }
  function isCornerCatch(ball, rect){
    const {rx,ry,w,h}=rect;
    const corners=[{cx:rx,cy:ry},{cx:rx+w,cy:ry},{cx:rx,cy:ry+h},{cx:rx+w,cy:ry+h}];
    const thresh = ball.r + 1.8;
    for (const k of corners){ if (Math.hypot(ball.x-k.cx, ball.y-k.cy) <= thresh) return {hit:true,cx:k.cx,cy:k.cy}; }
    return {hit:false};
  }

  function update(dt){
    const now = performance.now();
    maybeBoostSpeed(now);

    if (rowDropAnim > 0){ rowDropAnim -= dt / (ROW_DROP_MS / 1000); if (rowDropAnim < 0) rowDropAnim = 0; }
    for (const b of blocks) if (b.hitCooldown > 0) b.hitCooldown -= dt;

    if (state==='FIRING'){
      fireTimer += dt * 1000;
      while (fireTimer >= FIRE_INTERVAL && firedThisVolley < volleyTarget){ fireTimer -= FIRE_INTERVAL; addBall(); }
      if (firedThisVolley >= volleyTarget && balls.length === 0) finishVolley();
    }

    if (state==='FIRING' || state==='BETWEEN'){
      const steps=2, stepDT=dt/steps;
      for (let s=0;s<steps;s++){
        for (let i=balls.length-1;i>=0;i--){
          const b=balls[i];

          // Stuck behavior (safe release if brick gone or not near)
          if (b.stuck){
            if (!isBlockLive(b.stuckTo) || !anyBrickNear(b.stuckX,b.stuckY,BALL_R+2)){ releaseStuckBall(b); continue; }
            b.stuckTick += stepDT;
            if (b.stuckTick >= 0.05){
              b.stuckTick = 0;
              if (b.stuckTo && b.stuckTo.hp > 0){
                b.stuckTo.hp -= 1; score += 1; scoreEl.textContent = score; beep(700+Math.random()*40,0.015,0.02);
                if (b.stuckTo.hp <= 0) releaseStuckBall(b);
              } else releaseStuckBall(b);
            }
            continue;
          }

          // Integrate
          b.x += b.vx * stepDT; b.y += b.vy * stepDT;

          // Walls
          const left = PAD + BALL_R, right = pxW() - PAD - BALL_R;
          if (b.x <= left)  { b.x = left;  b.vx = Math.abs(b.vx); beep(900,0.02,0.01); }
          if (b.x >= right) { b.x = right; b.vx = -Math.abs(b.vx); beep(900,0.02,0.01); }
          const ceil = gridTop() + BALL_R;
          if (b.y <= ceil) { b.y = ceil; b.vy = Math.abs(b.vy); beep(900,0.02,0.01); }
          const floor = gridBottomY() - BALL_R;
          if (b.y >= floor){
            if (firstReturnX === null) firstReturnX = b.x;
            returnedThisVolley++; balls.splice(i,1);
            if (returnedThisVolley >= volleyTarget && state !== 'BETWEEN') finishVolley();
            continue;
          }

          // Block collisions
          for (let j=blocks.length-1;j>=0;j--){
            const blk=blocks[j]; if (blk.hitCooldown>0) continue;
            const rx=colX(blk.c), ry=rowY(blk.r), w=cellSize(), h=cellSize();
            const nx = clamp(b.x, rx, rx+w), ny = clamp(b.y, ry + dropOffset(), ry + h + dropOffset());
            const dx = b.x - nx, dy = b.y - ny, d2 = dx*dx + dy*dy;

            if (d2 < b.r*b.r){
              if (Math.abs(dx) > Math.abs(dy)) b.vx = (dx > 0) ? Math.abs(b.vx) : -Math.abs(b.vx);
              else b.vy = (dy > 0) ? Math.abs(b.vy) : -Math.abs(b.vy);
              const d = Math.sqrt(Math.max(0.0001,d2)), nxv = (d?dx/d:0), nyv = (d?dy/d:-1);
              b.x = nx + nxv*(b.r+0.1); b.y = ny + nyv*(b.r+0.1);

              blk.hp -= 1; blk.hitCooldown = 0.015; score += 1; scoreEl.textContent = score;
              beep(680+Math.random()*60,0.02,0.02);
              if (blk.hp <= 0){ blocks.splice(j,1); beep(520,0.06,0.03); break; }

              // Corner "stick"
              const corner = isCornerCatch(b,{rx,ry,w,h});
              if (corner.hit){
                b.stuck = true; b.stuckTo = blk; b.stuckX = corner.cx; b.stuckY = corner.cy;
                b.resumeVX = b.vx; b.resumeVY = b.vy; b.vx = 0; b.vy = 0; b.stuckTick=0; b.stuckMultAtStart = speedMultiplier;
              }
              break;
            }
          }

          // Pickups
          for (let j=pickups.length-1;j>=0;j--){
            const p=pickups[j], rx=colX(p.c), ry=rowY(p.r)+dropOffset(), w=cellSize(), h=cellSize();
            if (b.x>rx && b.x<rx+w && b.y>ry && b.y<ry+h){
              if (p.type==='ball'){ ballCount += 1; ballsEl.textContent = ballCount; pickups.splice(j,1); beep(880,0.06,0.03); }
            }
          }
        }
      }
    }
  }

  function dropOffset(){ return rowDropAnim>0 ? (1-rowDropAnim)*cellSize() : 0; }

  function finishVolley(){
    if (firstReturnX !== null){
      const left=PAD+BALL_R, right=pxW()-PAD-BALL_R;
      origin.x = clamp(firstReturnX, left, right);
    }
    state='BETWEEN'; level+=1; levelEl.textContent=level; spawnRow();
    setTimeout(()=>{ if (state!=='OVER') state='AIM'; }, ROW_DROP_MS+10);
  }

  // ---------- Rendering (clipped to board, pixel-snapped) ----------
  function draw(){
    const W = pxW(), H = pxH();
    ctx.clearRect(0,0,W,H);

    // Frame rectangle (non-clipped)
    const frameX = PAD-1, frameY = gridTop()-1, frameW = W - PAD*2 + 2, frameH = gridBottomY() - gridTop() + 2;
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.03)';
    ctx.fillRect(frameX, frameY, frameW, frameH);
    ctx.restore();

    // Clip to play field so nothing draws outside
    ctx.save();
    ctx.beginPath();
    ctx.rect(PAD, gridTop(), W - PAD*2, gridBottomY() - gridTop());
    ctx.clip();

    // Grid lines (half-pixel snap for crispness)
    ctx.strokeStyle='rgba(255,255,255,0.04)';
    ctx.lineWidth=1;
    for (let c=1;c<COLS;c++){
      const x = Math.round(colX(c)) + 0.5;
      ctx.beginPath(); ctx.moveTo(x, gridTop()); ctx.lineTo(x, gridBottomY()); ctx.stroke();
    }
    for (let r=1;r<MAX_ROWS;r++){
      const y = Math.round(rowY(r) + dropOffset()) + 0.5;
      ctx.beginPath(); ctx.moveTo(PAD, y); ctx.lineTo(W-PAD, y); ctx.stroke();
    }

    // Blocks (true rounded rects, safe joins)
    for (const b of blocks){
      const x = colX(b.c), y = rowY(b.r) + dropOffset(), s = cellSize();
      const pct = clamp(b.hp / (level + 6), 0, 1), col = hpColor(pct);
      const rr = Math.max(6, Math.floor(s * 0.18)); // adaptive radius
      roundedRectPath(ctx, x+4, y+4, s-8, s-8, rr);
      ctx.fillStyle = col.fill; ctx.fill();
      ctx.lineWidth = Math.max(1.25, s*0.03);
      ctx.strokeStyle = col.stroke; ctx.stroke();

      // HP label
      ctx.fillStyle = '#eaf2ff';
      ctx.font = `${Math.floor(s*0.32)}px ui-sans-serif, system-ui`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(String(b.hp), x + s/2, y + s/2 + 1);
    }

    // Pickups
    for (const p of pickups){
      const x=colX(p.c), y=rowY(p.r)+dropOffset(), s=cellSize();
      const cx=x+s/2, cy=y+s/2; const t=(performance.now()/1000)+p.pulse; const r=Math.max(8, s*0.18)+Math.sin(t*2)*1.3;
      ctx.beginPath(); ctx.arc(cx,cy,r+6,0,Math.PI*2); ctx.fillStyle='rgba(119,255,119,0.12)'; ctx.fill();
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fillStyle='#35d66b'; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='#0c9a3f'; ctx.stroke();
      ctx.strokeStyle='#0a3'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(cx-r*0.45,cy); ctx.lineTo(cx+r*0.45,cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx,cy-r*0.45); ctx.lineTo(cx,cy+r*0.45); ctx.stroke();
    }

    // Aim guide
    if (state==='AIM' && (aiming || aimPoint)){
      const a = aimPoint || {x:origin.x, y:origin.y-80};
      const dx=a.x-origin.x, dy=a.y-origin.y;
      let ang=Math.atan2(dy,dx); if (ang>UPWARD_LIMIT) ang=UPWARD_LIMIT;
      const center=-Math.PI/2; ang=clamp(ang, center-MAX_AIM_ANGLE, center+MAX_AIM_ANGLE);
      const dir={x:Math.cos(ang), y:Math.sin(ang)}, len=Math.min(200, cellSize()*5);
      ctx.strokeStyle='rgba(93,211,255,0.85)'; ctx.lineWidth=3; ctx.setLineDash([8,8]);
      ctx.beginPath(); ctx.moveTo(origin.x,origin.y); ctx.lineTo(origin.x+dir.x*len, origin.y+dir.y*len); ctx.stroke(); ctx.setLineDash([]);
      ctx.beginPath(); ctx.arc(origin.x+dir.x*len, origin.y+dir.y*len, 4, 0, Math.PI*2); ctx.fillStyle='rgba(93,211,255,0.9)'; ctx.fill();
    }

    // Origin + balls
    ctx.beginPath(); ctx.arc(origin.x, origin.y, BALL_R+2, 0, Math.PI*2);
    ctx.fillStyle='#d0f1ff'; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='#5dd3ff'; ctx.stroke();

    const tNow=performance.now()/1000;
    for (const b of balls){
      let drawX=b.x, drawY=b.y;
      if (b.stuck && b.stuckTo){ const j=Math.sin(tNow*50)*0.6; drawX=b.stuckX+j; drawY=b.stuckY-j; }
      ctx.beginPath(); ctx.arc(drawX, drawY, BALL_R, 0, Math.PI*2);
      ctx.fillStyle='#e8fbff'; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='rgba(93,211,255,0.6)'; ctx.stroke();
    }

    ctx.restore(); // end clip
  }

  function roundedRectPath(c, x, y, w, h, r){
    // robust rounded rectangle path (prevents “star” artefacts at tiny sizes)
    r = Math.max(0, Math.min(r, Math.min(w, h)/2));
    c.beginPath();
    c.moveTo(x+r, y);
    c.arcTo(x+w, y,   x+w, y+h, r);
    c.arcTo(x+w, y+h, x,   y+h, r);
    c.arcTo(x,   y+h, x,   y,   r);
    c.arcTo(x,   y,   x+w, y,   r);
    c.closePath();
  }

  function hpColor(p){
    const lerp=(a,b,t)=>a+(b-a)*t, toHex=v=>('0'+Math.round(clamp(v,0,255)).toString(16)).slice(-2);
    const g={r:80,g:220,b:140}, y={r:255,g:210,b:90}, r={r:255,g:100,b:100};
    let c1,c2,t; if (p<0.5){ c1=g; c2=y; t=p/0.5; } else { c1=y; c2=r; t=(p-0.5)/0.5; }
    const rr=lerp(c1.r,c2.r,t), gg=lerp(c1.g,c2.g,t), bb=lerp(c1.b,c2.b,t);
    return { fill:`#${toHex(rr)}${toHex(gg)}${toHex(bb)}`, stroke:`rgba(0,0,0,0.35)` };
  }

  // ---------- Main loop ----------
  let last=performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    if (paused || state==='OVER' || state==='READY'){ draw(); return; }
    const dt = clamp((now - last)/1000, 0, 0.033); last = now;
    update(dt); draw();
  }
  requestAnimationFrame(loop);

  // Start screen
  function showStart(){
    state='READY'; startOverlay.style.display='';
    levelEl.textContent=1; ballsEl.textContent=1; scoreEl.textContent=0;
  }
  showStart();
})();
</script>
</body>
</html>


