---
title: "BallCrusher v0.5"
---


<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>One-Shot Brick Volley — v6</title>
<style>
  :root {
    --bg: #0f1221; --panel: #151833; --accent: #5dd3ff;
    --good: #77ff77; --warn: #ffcc66; --bad: #ff6b6b;
    --text: #e7ecf2; --muted: #96a1b0;
  }
  html, body { margin:0; height:100%; background: radial-gradient(1200px 800px at 30% -10%, #1b2044 0%, var(--bg) 60%); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
  .wrap {
    max-width: 720px;  /* visually smaller like v1 */
    margin: 0 auto;
    padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom);
    display: grid; grid-template-rows: auto 1fr auto; gap: 10px; height: 100dvh; box-sizing: border-box;
  }
  header, footer {
    display:flex; align-items:center; justify-content:space-between;
    background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.08));
    border:1px solid rgba(255,255,255,0.08);
    border-radius:12px; padding:8px 12px; backdrop-filter: blur(6px);
  }
  header .stat { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:8px; background:#101433; border:1px solid rgba(255,255,255,0.08); font-weight:600; }
  header .stat .dot { width:8px; height:8px; border-radius:50%; background:var(--accent); }
  header .btns { display:inline-flex; gap:8px; }
  button { appearance:none; border:1px solid rgba(255,255,255,0.14); background:#111534; color:var(--text); padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer; }
  button:hover { filter:brightness(1.06); } button:active { transform: translateY(0.5px); }
  #gameCanvas {
    width:100%; height:auto; display:block;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12)),
                radial-gradient(900px 600px at 70% 10%, rgba(93,211,255,0.08), rgba(0,0,0,0) 60%);
    border-radius:14px; border:1px solid rgba(255,255,255,0.08);
    box-shadow:0 10px 40px rgba(0,0,0,0.35), inset 0 0 40px rgba(93,211,255,0.08);
    touch-action:none;
  }
  .overlay { position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
  .card { pointer-events:auto; background:var(--panel); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:18px; max-width:520px; box-shadow:0 10px 40px rgba(0,0,0,0.5); text-align:center; }
  .title { font-weight:800; font-size:24px; letter-spacing:0.2px; margin:4px 0 2px; }
  .subtitle { color:var(--muted); margin-bottom:14px; }
  .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0e1230; border:1px solid rgba(255,255,255,0.12); padding:2px 6px; border-radius:6px; }
  footer { justify-content:center; gap:16px; color:var(--muted); font-size:14px; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="stat"><span class="dot"></span> Level <span id="levelVal">1</span></div>
      <div class="stat"><span class="dot" style="background:var(--good)"></span> Balls <span id="ballsVal">1</span></div>
      <div class="stat"><span class="dot" style="background:var(--warn)"></span> Score <span id="scoreVal">0</span></div>
      <div class="btns">
        <button id="pauseBtn" aria-label="Pause">Pause</button>
        <button id="restartBtn" aria-label="Restart">Restart</button>
        <button id="muteBtn" aria-label="Mute">Mute</button>
      </div>
    </header>

    <div style="position:relative;">
      <canvas id="gameCanvas" width="600" height="960" aria-label="Brick volley game area"></canvas>

      <div id="startOverlay" class="overlay">
        <div class="card">
          <div class="title">One-Shot Brick Volley</div>
          <div class="subtitle">Drag to aim. Release to shoot. Pick up <strong>+1</strong> balls. Keep blocks off the bottom.</div>
          <p style="margin:10px 0 14px;">
            Desktop: click and drag. Mobile: touch and drag.
            Press <span class="kbd">R</span> to restart, <span class="kbd">P</span> to pause.
          </p>
          <button id="startBtn">Play</button>
        </div>
      </div>

      <div id="pauseOverlay" class="overlay" style="display:none;">
        <div class="card">
          <div class="title">Paused</div>
          <div class="subtitle">Take a breather.</div>
          <button id="resumeBtn">Resume</button>
        </div>
      </div>

      <div id="gameOverOverlay" class="overlay" style="display:none;">
        <div class="card">
          <div class="title">Game Over</div>
          <div class="subtitle">A block reached the bottom row.</div>
          <p style="margin: 6px 0 14px;">
            Score: <strong id="finalScore">0</strong> · Best: <strong id="bestScore">0</strong>
          </p>
          <button id="againBtn">Play Again</button>
        </div>
      </div>
    </div>

    <footer><div>Tip: corner clips can “stick” a ball; long volleys get faster.</div></footer>
  </div>

<script>
(() => {
  // ---------- Canvas + DPI ----------
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function fitCanvas() {
    const cssW = Math.min(window.innerWidth - 24, 720);
    const aspect = 600 / 960;
    let w = cssW, h = Math.floor(w / aspect);
    const maxH = Math.max(420, Math.min(window.innerHeight - 172, 1100));
    if (h > maxH) { h = maxH; w = Math.floor(h * aspect); }
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  // ---------- Game constants ----------
  const COLS = 12, PAD = 14, TOP_PAD = 70, MAX_ROWS = 13;
  const BALL_R = 6;
  const BASE_SPEED = 420, FIRE_INTERVAL = 55, ROW_DROP_MS = 180;
  const PICKUP_RATE = 0.22, BLOCK_RATE_BASE = 0.55;

  const MAX_AIM_ANGLE = Math.PI * 0.499;  // ~±89.8°
  const UPWARD_LIMIT = -0.001;

  const SPEED1_AFTER_MS = 10000, SPEED1_MULT = 1.75;
  const SPEED2_AFTER_MS = 30000, SPEED2_MULT = 2.5;

  let state = 'READY';
  let level = 1, score = 0;
  let best = Number(localStorage.getItem('oneShotBest') || 0);

  // Grid metrics
  function cellSize() { return (canvas.width/(window.devicePixelRatio||1) - PAD*2) / COLS; }
  function gridLeft() { return PAD; }
  function gridTop() { return TOP_PAD; }
  function gridBottomY() { return gridTop() + MAX_ROWS * cellSize(); }

  // UI
  const levelEl = document.getElementById('levelVal');
  const ballsEl = document.getElementById('ballsVal');
  const scoreEl = document.getElementById('scoreVal');
  const startOverlay = document.getElementById('startOverlay');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreEl = document.getElementById('finalScore');
  const bestScoreEl = document.getElementById('bestScore');

  document.getElementById('startBtn').onclick = startGame;
  document.getElementById('againBtn').onclick = restart;
  document.getElementById('pauseBtn').onclick = togglePause;
  document.getElementById('resumeBtn').onclick = togglePause;
  document.getElementById('restartBtn').onclick = restart;
  const muteBtn = document.getElementById('muteBtn'); let muted = false;
  muteBtn.onclick = () => { muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Mute'; };

  window.addEventListener('keydown', e => {
    if (e.key === 'p' || e.key === 'P') togglePause();
    if (e.key === 'r' || e.key === 'R') restart();
  });

  // ---------- Entities ----------
  const blocks = [];
  const pickups = [];
  let balls = [];

  let ballCount = 1;
  let volleyTarget = 1;

  let origin = { x: canvas.width/(window.devicePixelRatio||1) / 2, y: gridBottomY() - 22 };

  let pendingFireDir = null;
  let fireTimer = 0;
  let firedThisVolley = 0;
  let returnedThisVolley = 0;
  let firstReturnX = null;
  let rowDropAnim = 0;
  let paused = false;

  // Speed state
  let volleyStartMs = 0;
  let speedMultiplier = 1;
  let lastAppliedMultiplier = 1;

  // ---------- Simple SFX ----------
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function beep(freq=600, time=0.05, gain=0.03) {
    if (muted) return;
    if (!audioCtx) { try { audioCtx = new AudioContext(); } catch {} }
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square'; o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + time);
  }

  // ---------- Utility ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  function worldFromEvent(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.touches ? ev.touches[0].clientX : ev.clientX) - rect.left;
    const y = (ev.touches ? ev.touches[0].clientY : ev.clientY) - rect.top;
    return { x, y };
  }
  function colX(c) { return gridLeft() + c * cellSize(); }
  function rowY(r) { return gridTop() + r * cellSize(); }

  // NEW: helpers to manage the stuck-corner behavior safely
  function isBlockLive(blk) {
    return !!(blk && blk.hp > 0 && blocks.indexOf(blk) !== -1);
  }
  function anyBrickNear(x, y, tol = BALL_R + 2) {
    for (const blk of blocks) {
      const rx = colX(blk.c), ry = rowY(blk.r) + dropOffset();
      const w = cellSize(), h = cellSize();
      if (x >= rx - tol && x <= rx + w + tol && y >= ry - tol && y <= ry + h + tol) return true;
    }
    return false;
  }
  function releaseStuckBall(b) {
    const scale = speedMultiplier / (b.stuckMultAtStart || 1);
    // Resume along saved post-bounce direction. Fallbacks keep it moving upward.
    b.vx = (b.resumeVX || ((Math.random()<0.5?-1:1) * BASE_SPEED * 0.6)) * scale;
    b.vy = (b.resumeVY || -BASE_SPEED * 0.6) * scale;
    // Tiny nudge so it doesn't re-collide in-place
    b.x = b.stuckX + (b.vx > 0 ? 0.6 : -0.6);
    b.y = b.stuckY + (b.vy > 0 ? 0.6 : -0.6);
    b.stuck = false; b.stuckTo = null;
  }

  // ---------- Row spawning ----------
  function spawnRow() {
    for (const b of blocks) b.r += 1;
    for (const p of pickups) p.r += 1;

    for (const b of blocks) { if (b.r >= MAX_ROWS) { gameOver(); return; } }

    const r = 0;
    const spawnChance = clamp(BLOCK_RATE_BASE + level * 0.01, 0.55, 0.9);
    let spawned = 0;
    for (let c = 0; c < COLS; c++) {
      if (Math.random() < spawnChance) {
        const hp = Math.max(1, Math.floor(level + (Math.random() * (2 + level * 0.2))));
        blocks.push({ c, r, hp, hitCooldown: 0 });
        spawned++;
      } else if (Math.random() < PICKUP_RATE) {
        pickups.push({ c, r, type: 'ball', pulse: Math.random()*Math.PI*2 });
      }
    }
    if (spawned === 0) {
      const c = Math.floor(Math.random() * COLS);
      blocks.push({ c, r, hp: level, hitCooldown: 0 });
    }
    rowDropAnim = 1;
  }

  // ---------- Lifecycle ----------
  function startGame() {
    startOverlay.style.display = 'none';
    state = 'AIM';
    beep(440, 0.06, 0.02);
    level = 1; score = 0;
    blocks.length = 0; pickups.length = 0; balls = [];
    ballCount = 1; volleyTarget = 1;
    firedThisVolley = 0; returnedThisVolley = 0; firstReturnX = null;
    speedMultiplier = 1; lastAppliedMultiplier = 1;
    levelEl.textContent = level; ballsEl.textContent = ballCount; scoreEl.textContent = score;
    origin.x = canvas.width/(window.devicePixelRatio||1) / 2;
    origin.y = gridBottomY() - 22;
    spawnRow();
  }
  function restart() {
    if (state === 'READY') { startOverlay.style.display = ''; return; }
    gameOverOverlay.style.display = 'none';
    startGame();
  }
  function togglePause() {
    if (state === 'OVER' || state === 'READY') return;
    paused = !paused;
    pauseOverlay.style.display = paused ? '' : 'none';
  }
  function gameOver() {
    state = 'OVER';
    best = Math.max(best, score);
    localStorage.setItem('oneShotBest', String(best));
    finalScoreEl.textContent = String(score);
    bestScoreEl.textContent = String(best);
    gameOverOverlay.style.display = '';
    beep(160, 0.2, 0.04);
  }

  // ---------- Input / Firing ----------
  let aiming = false;
  let aimPoint = null;

  const startAim = (e) => { if (state !== 'AIM') return; e.preventDefault(); aiming = true; aimPoint = worldFromEvent(e); };
  const moveAim  = (e) => { if (!aiming) return; aimPoint = worldFromEvent(e); };
  const endAim   = (e) => {
    if (!aiming) return;
    aiming = false;
    if (!aimPoint) return;
    const dx = aimPoint.x - origin.x;
    const dy = aimPoint.y - origin.y;
    let angle = Math.atan2(dy, dx);
    if (angle > UPWARD_LIMIT) angle = UPWARD_LIMIT;
    const center = -Math.PI/2;
    angle = clamp(angle, center - MAX_AIM_ANGLE, center + MAX_AIM_ANGLE);
    pendingFireDir = { x: Math.cos(angle), y: Math.sin(angle) };
    startVolley();
  };

  canvas.addEventListener('pointerdown', startAim);
  canvas.addEventListener('pointermove', moveAim);
  window.addEventListener('pointerup', endAim);
  canvas.addEventListener('touchstart', startAim, { passive:false });
  canvas.addEventListener('touchmove', moveAim, { passive:false });
  canvas.addEventListener('touchend', endAim);

  function startVolley() {
    if (!pendingFireDir || state !== 'AIM') return;
    state = 'FIRING';
    volleyTarget = ballCount;
    firedThisVolley = 0; returnedThisVolley = 0; firstReturnX = null; fireTimer = 0;
    volleyStartMs = performance.now();
    speedMultiplier = 1; lastAppliedMultiplier = 1;
    beep(520, 0.05, 0.03);
  }

  // ---------- Speed boosts ----------
  function maybeBoostSpeed(nowMs) {
    if (state !== 'FIRING') return;
    const elapsed = nowMs - volleyStartMs;
    let targetMult = 1;
    if (elapsed >= SPEED2_AFTER_MS) targetMult = SPEED2_MULT;
    else if (elapsed >= SPEED1_AFTER_MS) targetMult = SPEED1_MULT;

    if (targetMult > lastAppliedMultiplier) {
      const scale = targetMult / lastAppliedMultiplier;
      speedMultiplier = targetMult;
      for (const b of balls) { if (!b.stuck) { b.vx *= scale; b.vy *= scale; } }
      lastAppliedMultiplier = targetMult;
      beep(targetMult > SPEED1_MULT ? 1180 : 980, 0.08, 0.03);
    }
  }

  // ---------- Physics ----------
  function addBall() {
    const dir = pendingFireDir;
    const spd = BASE_SPEED * speedMultiplier;
    balls.push({
      x: origin.x, y: origin.y,
      vx: dir.x * spd, vy: dir.y * spd,
      r: BALL_R,
      stuck: false, stuckTo: null, stuckX: 0, stuckY: 0,
      resumeVX: 0, resumeVY: 0, stuckTick: 0, stuckMultAtStart: 1
    });
    firedThisVolley++;
    if (firedThisVolley >= volleyTarget) pendingFireDir = null;
  }

  function isCornerCatch(ball, blkRect) {
    const {rx, ry, w, h} = blkRect;
    const corners = [
      {cx: rx,     cy: ry},
      {cx: rx+w,   cy: ry},
      {cx: rx,     cy: ry+h},
      {cx: rx+w,   cy: ry+h}
    ];
    const thresh = ball.r + 1.8;
    for (const k of corners) {
      const d = Math.hypot(ball.x - k.cx, ball.y - k.cy);
      if (d <= thresh) return {hit:true, cx:k.cx, cy:k.cy};
    }
    return {hit:false};
  }

  function update(dt) {
    const nowMs = performance.now();
    maybeBoostSpeed(nowMs);

    if (rowDropAnim > 0) {
      rowDropAnim -= dt / (ROW_DROP_MS/1000);
      if (rowDropAnim < 0) rowDropAnim = 0;
    }

    for (const b of blocks) if (b.hitCooldown > 0) b.hitCooldown -= dt;

    if (state === 'FIRING') {
      fireTimer += dt * 1000;
      while (fireTimer >= FIRE_INTERVAL && firedThisVolley < volleyTarget) {
        fireTimer -= FIRE_INTERVAL; addBall();
      }
      if (firedThisVolley >= volleyTarget && balls.length === 0) finishVolley();
    }

    if (state === 'FIRING' || state === 'BETWEEN') {
      const steps = 2, stepDT = dt / steps;
      for (let s = 0; s < steps; s++) {
        for (let i = balls.length - 1; i >= 0; i--) {
          const b = balls[i];

          // Safe stuck behavior: release if brick is gone or not near
          if (b.stuck) {
            if (!isBlockLive(b.stuckTo) || !anyBrickNear(b.stuckX, b.stuckY, BALL_R + 2)) {
              releaseStuckBall(b);
              continue;
            }
            b.stuckTick += stepDT;
            if (b.stuckTick >= 0.05) {
              b.stuckTick = 0;
              if (b.stuckTo && b.stuckTo.hp > 0) {
                b.stuckTo.hp -= 1;
                score += 1; scoreEl.textContent = score;
                beep(700 + Math.random()*40, 0.015, 0.02);
                if (b.stuckTo.hp <= 0) {
                  releaseStuckBall(b);
                }
              } else {
                // safety net
                releaseStuckBall(b);
              }
            }
            continue; // do not integrate while stuck
          }

          // Normal integration
          b.x += b.vx * stepDT;
          b.y += b.vy * stepDT;

          // Walls
          const left = PAD + BALL_R;
          const right = (canvas.width/(window.devicePixelRatio||1)) - PAD - BALL_R;
          if (b.x <= left)  { b.x = left;  b.vx = Math.abs(b.vx); beep(900,0.02,0.01); }
          if (b.x >= right) { b.x = right; b.vx = -Math.abs(b.vx); beep(900,0.02,0.01); }
          // Ceiling
          const ceil = gridTop() + BALL_R;
          if (b.y <= ceil) { b.y = ceil; b.vy = Math.abs(b.vy); beep(900,0.02,0.01); }
          // Floor return
          const floor = gridBottomY() - BALL_R;
          if (b.y >= floor) {
            if (firstReturnX === null) firstReturnX = b.x;
            returnedThisVolley++;
            balls.splice(i,1);
            if (returnedThisVolley >= volleyTarget && state !== 'BETWEEN') finishVolley();
            continue;
          }

          // Block collisions
          for (let j = blocks.length - 1; j >= 0; j--) {
            const blk = blocks[j];
            if (blk.hitCooldown > 0) continue;
            const rx = colX(blk.c), ry = rowY(blk.r), w = cellSize(), h = cellSize();
            const nx = clamp(b.x, rx, rx + w);
            const ny = clamp(b.y, ry + dropOffset(), ry + h + dropOffset());
            const dx = b.x - nx, dy = b.y - ny;
            const d2 = dx*dx + dy*dy;

            if (d2 < b.r * b.r) {
              // compute bounce
              if (Math.abs(dx) > Math.abs(dy)) { b.vx = (dx > 0) ? Math.abs(b.vx) : -Math.abs(b.vx); }
              else { b.vy = (dy > 0) ? Math.abs(b.vy) : -Math.abs(b.vy); }
              const d = Math.sqrt(Math.max(0.0001, d2));
              const nxv = (d ? dx/d : 0), nyv = (d ? dy/d : -1);
              b.x = nx + nxv * (b.r + 0.1);
              b.y = ny + nyv * (b.r + 0.1);

              // Damage once for initial hit
              blk.hp -= 1; blk.hitCooldown = 0.015;
              score += 1; scoreEl.textContent = score;
              beep(680 + Math.random()*60, 0.02, 0.02);
              if (blk.hp <= 0) { blocks.splice(j,1); beep(520, 0.06, 0.03); break; }

              // Intentional corner "stick" trigger
              const corner = isCornerCatch(b, {rx, ry, w, h});
              if (corner.hit) {
                b.stuck = true;
                b.stuckTo = blk;
                b.stuckX = corner.cx; b.stuckY = corner.cy;
                b.resumeVX = b.vx; b.resumeVY = b.vy; // save post-bounce path
                b.vx = 0; b.vy = 0; b.stuckTick = 0;
                b.stuckMultAtStart = speedMultiplier;
              }
              break;
            }
          }

          // Pickups
          for (let j = pickups.length - 1; j >= 0; j--) {
            const p = pickups[j];
            const rx = colX(p.c), ry = rowY(p.r) + dropOffset();
            const w = cellSize(), h = cellSize();
            if (b.x > rx && b.x < rx+w && b.y > ry && b.y < ry+h) {
              if (p.type === 'ball') {
                ballCount += 1; ballsEl.textContent = ballCount;
                pickups.splice(j,1); beep(880, 0.06, 0.03);
              }
            }
          }
        }
      }
    }
  }

  function dropOffset() { return rowDropAnim > 0 ? (1 - rowDropAnim) * cellSize() : 0; }

  function finishVolley() {
    if (firstReturnX !== null) {
      const left = PAD + BALL_R;
      const right = (canvas.width/(window.devicePixelRatio||1)) - PAD - BALL_R;
      origin.x = clamp(firstReturnX, left, right);
    }
    state = 'BETWEEN';
    level += 1; levelEl.textContent = level;
    spawnRow();
    setTimeout(() => { if (state !== 'OVER') state = 'AIM'; }, ROW_DROP_MS + 10);
  }

  // ---------- Rendering ----------
  function draw() {
    const W = canvas.width/(window.devicePixelRatio||1);
    const H = canvas.height/(window.devicePixelRatio||1);
    ctx.clearRect(0,0,W,H);

    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(PAD-1, gridTop()-1, W - (PAD*2) + 2, gridBottomY() - gridTop() + 2);
    ctx.restore();

    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
    for (let c=1; c<COLS; c++){ const x = colX(c); ctx.beginPath(); ctx.moveTo(x, gridTop()); ctx.lineTo(x, gridBottomY()); ctx.stroke(); }
    for (let r=1; r<MAX_ROWS; r++){ const y = rowY(r) + dropOffset(); ctx.beginPath(); ctx.moveTo(PAD, y); ctx.lineTo(W-PAD, y); ctx.stroke(); }
    ctx.restore();

    for (const b of blocks) {
      const x = colX(b.c), y = rowY(b.r) + dropOffset(), s = cellSize();
      const pct = clamp(b.hp / (level + 6), 0, 1);
      const col = hpColor(pct);
      roundRect(ctx, x+4, y+4, s-8, s-8, 10);
      ctx.fillStyle = col.fill; ctx.fill();
      ctx.strokeStyle = col.stroke; ctx.lineWidth = 2; ctx.stroke();
      ctx.fillStyle = '#eaf2ff';
      ctx.font = `${Math.floor(s*0.32)}px ui-sans-serif, system-ui`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(String(b.hp), x + s/2, y + s/2 + 1);
    }

    for (const p of pickups) {
      const x = colX(p.c), y = rowY(p.r) + dropOffset(), s = cellSize();
      const cx = x + s/2, cy = y + s/2;
      const t = (performance.now()/1000) + p.pulse;
      const r = Math.max(8, s*0.18) + Math.sin(t*2)*1.3;
      ctx.beginPath(); ctx.arc(cx, cy, r+6, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(119,255,119,0.12)'; ctx.fill();
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fillStyle = '#35d66b'; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = '#0c9a3f'; ctx.stroke();
      ctx.strokeStyle = '#0a3'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(cx - r*0.45, cy); ctx.lineTo(cx + r*0.45, cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx, cy - r*0.45); ctx.lineTo(cx, cy + r*0.45); ctx.stroke();
    }

    if (state === 'AIM' && (aiming || aimPoint)) {
      const a = aimPoint || {x: origin.x, y: origin.y - 80};
      const dx = a.x - origin.x, dy = a.y - origin.y;
      let ang = Math.atan2(dy, dx);
      if (ang > UPWARD_LIMIT) ang = UPWARD_LIMIT;
      const center = -Math.PI/2;
      ang = clamp(ang, center - MAX_AIM_ANGLE, center + MAX_AIM_ANGLE);
      const dir = { x: Math.cos(ang), y: Math.sin(ang) };
      const len = 160;
      ctx.strokeStyle = 'rgba(93,211,255,0.85)'; ctx.lineWidth = 3; ctx.setLineDash([8,8]);
      ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(origin.x + dir.x * len, origin.y + dir.y * len); ctx.stroke();
      ctx.setLineDash([]); ctx.beginPath(); ctx.arc(origin.x + dir.x * len, origin.y + dir.y * len, 4, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(93,211,255,0.9)'; ctx.fill();
    }

    ctx.beginPath(); ctx.arc(origin.x, origin.y, BALL_R+2, 0, Math.PI*2);
    ctx.fillStyle = '#d0f1ff'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#5dd3ff'; ctx.stroke();

    const tNow = performance.now()/1000;
    for (const b of balls) {
      let drawX = b.x, drawY = b.y;
      if (b.stuck && b.stuckTo) {
        const j = Math.sin(tNow*50) * 0.6;
        drawX = b.stuckX + j;
        drawY = b.stuckY - j;
      }
      ctx.beginPath(); ctx.arc(drawX, drawY, BALL_R, 0, Math.PI*2);
      ctx.fillStyle = '#e8fbff'; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(93,211,255,0.6)'; ctx.stroke();
    }
  }

  function hpColor(p) {
    const lerp = (a,b,t)=>a+(b-a)*t, toHex = v => ('0'+Math.round(clamp(v,0,255)).toString(16)).slice(-2);
    const g = {r:80,g:220,b:140}, y = {r:255,g:210,b:90}, r = {r:255,g:100,b:100};
    let c1, c2, t; if (p < 0.5) { c1=g; c2=y; t=p/0.5; } else { c1=y; c2=r; t=(p-0.5)/0.5; }
    const rr=lerp(c1.r,c2.r,t), gg=lerp(c1.g,c2.g,t), bb=lerp(c1.b,c2.b,t);
    return { fill:`#${toHex(rr)}${toHex(gg)}${toHex(bb)}`, stroke:`rgba(0,0,0,0.35)` };
  }
  function roundRect(ctx, x, y, w, h, r) { ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); }

  // ---------- Main loop ----------
  let last = performance.now();
  function loop(now) {
    requestAnimationFrame(loop);
    if (paused || state === 'OVER' || state === 'READY') { draw(); return; }
    const dt = clamp((now - last)/1000, 0, 0.033); last = now;
    update(dt); draw();
  }
  requestAnimationFrame(loop);

  function showStart() {
    state = 'READY';
    startOverlay.style.display = '';
    levelEl.textContent = 1; ballsEl.textContent = 1; scoreEl.textContent = 0;
  }
  showStart();
})();
</script>
</body>
</html>



